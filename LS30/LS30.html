<!DOCTYPE html>
<html>
<head>
	<title></title>
	<meta charset="utf-8">
</head>
<body>

</body>
<script type="text/javascript">
//一、ES6新增的箭头函数
	//箭头函数语法简单地描述为：参数 => 函数体 或 （参数） => { 函数体 }
	//优点：可减少冗余的代码（如function关键字等）节省空间，避免this指向错误
	//如果箭头函数不需要参数或需要多个参数时，就使用一个圆括号代表参数部分
//ES6的写法
	//单语句不用写大括号和return关键字;但如果使用复合语句，需要使用大括号和对应的return语句进行返回
var max=(a,b) => a>b?a:b;
max(2,3);  //3

//等同于
var max=function(a,b){
	return a>b?a:b;
}
max(2,3); //3

var f=v => v+1;  //单参数可以不用()
f(2);  //3

	//没有参数和有多个参数的情况下，需要使用小括号来表示参数，如果有多条语句则需要有大括号表示函数体
var f = () => 5;
	// 等同于
var f = function () {
    return 5;
};
f(); //5

var foo = (num1, num2) => {
    if (num1 > num2) {
        return num1 * 2;
    } else {
        return num2 * 2;
    }
};
foo(2,3);

	//箭头函数可以与变量解构结合使用
const full = ({ first, last }) => last + ' ' + first;
full({first:"Ming",last:"Li"});  //"Li Ming"

	// 等同于
function full({ first, last }) {
  return last + ' ' + first;
}
full({first:"Ming",last:"Li"});

	//如果返回的是一个对象,需用()包起来
var getTempTtem=itemId =>({id:itemId,name:"temp"});
getTempTtem(23);  //{id: 23, name: "temp"}
	
	//函数内的 this是与函数定义时所在的对象绑定，而不是使用时所在的对象（避免this缺陷）
var point = {
    x:0,
    y:0,
    moveTo:function (x,y) {
        //内部嵌套函数
        var moveToX = ()=>this.x=x;
        //内部嵌套函数
        var moveToY = ()=>this.y=y;
        moveToX();
        moveToY();
    }
};
point.moveTo(2,2);  //{x: 2, y: 2, moveTo: ƒ}
console.log(point);
console.log(window.x,window.y);  //undefined undefined

// 箭头函数有几个使用注意点。
// （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
// （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
// （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。
// （4）不可以使用yield命令，因此箭头函数不能用作Generator函数

	//思考函数中的this ES5中如何解决
function foo() {
    setTimeout(function(){
        console.log('id:', this.id);
    }, 2000);
}
var id = 21;
foo.call({ id: 42 });// id: 21

	//查看下例中箭头函数的写法和结果
function foo() {
    setTimeout(() => {
        console.log('id:', this.id);
    }, 2000);
}
var id = 21;
foo.call({ id: 42 });// id: 42
	
//二、ES6对函数参数默认值的扩展
//ES5中不能直接为函数的参数指定默认值，需通过 || 来实现
var sum = function(a,b,c){
    b = b||4;
    c = c||5;
    return a+b+c;
};
console.log(sum(1,2,3));//1+2+3
console.log(sum(1,2));//1+2+5
console.log(sum(1));//1+4+5
console.log(sum(1,0,0));//本应为1+0+0，但此处为1+4+5，代码有问题需优化，优化如下

	//优化改造版本
var sum = function(a,b,c){
    if(b!=false){b = b||4;}//(b!=false)&&(b=b||4);
    if(c!=false){c = c||5;}//(c!=false)&&(c=c||5);
    return a+b+c;
};
console.log(sum(1,2,3));//1+2+3
console.log(sum(1,2));//1+2+5
console.log(sum(1));//1+4+5
console.log(sum(1,0,0));//1+0+0

//ES6允许为函数的参数设置默认值，直接写在参数定义的后面，比ES5更加直观，不会出现ES5中实参转换为布尔类型的问题
var sum = function(a,b=4,c=5){
    return a+b+c;
};
console.log(sum(1,2,3));//1+2+3
console.log(sum(1,2));//1+2+5
console.log(sum(1));//1+4+5
console.log(sum(1,0,0));//1+0+0

//ES6函数的参数默认值注意事项
//带默认值的参数变量是默认声明的，所以函数体内不能再用let或const重复声明
function foo(x=5){
    let x = 1;//报错
    const x = 2;//报错
    var x = 3;//正常
}
foo();

//参数一般有顺序，有默认值的参数应该是尾参数
function f(x = 1,y) {
    return [x,y];
}
f();//[1,undefined]
f(2);//[2,undefined]
f(,3);//报错，无法使x用1，y用3


//所以有默认值的参数在最后
function f(x,y = 1) {
    return [x,y];
}
f();//[undefined, 1]
f(2);//[2, 1] 这样就可以x为传递的参数，y为默认的值

//三、ES6中的Rest与Spread操作符
//...Rest（剩余操作符） 主要用在函数参数的声明中，可获得隐含的实参，取代ES5中函数隐藏变量arguments
	// 相当于合并若干参数为一个数组，主要用于函数定义时，代替 arguments，组解决arguments的弊端
function f(...y){
    console.log(y);
}
f("a","b","c");//输出 ["a","b","c"]

function f(x,...y){
    console.log(x,y);
}
f("a","b","c","d");//输出 a ["b","c","d"]
f("a",["b","c","d"]);//输出 a [["b","c","d"]]
f("a");//输出 a []
f();//输出 undefined []

//...Spread（扩展操作符） 主要用在函数的调用中使用（虽然也是...，但使用的场景不同）
	//Spread将一个数组转换为用逗号分隔的参数序列，是...Rest的逆过程
function f(x,...y){
    console.log(x,y);
}
f("a",...["b","c"]);//等价于f("a","b","c"); 输出 a ["b","c"]
f("a");//输出 a []
f();//输出 undefined []

function a(x,y){
	console.log(x,y);
}
var arr=[1,2];
a.apply({},arr);
a.call({},arr[0],arr[1]);
a.call({},...arr)
</script>
</html>